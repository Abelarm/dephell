# built-in
import asyncio
import re
from copy import deepcopy
from typing import Optional, List, Iterable

# external
import attr
from cached_property import cached_property
from packaging.utils import canonicalize_name
from packaging.requirements import Requirement as PackagingRequirement

# app
from ..links import VCSLink, parse_link
from ..repositories import GitRepo, get_repo
from .constraint import Constraint
from .git_specifier import GitSpecifier
from .groups import Groups
from ..markers import Markers


loop = asyncio.get_event_loop()

# regex for names generated by pipenv
rex_hash = re.compile(r'[a-f0-9]{7}')


@attr.s(cmp=False)
class Dependency:
    raw_name = attr.ib(type=str)
    constraint = attr.ib(type=Constraint, repr=False)
    repo = attr.ib(repr=False)
    link = attr.ib(default=None, repr=False)

    # flags
    applied = attr.ib(type=bool, default=False, repr=False)

    # optional info
    description = attr.ib(type=str, default='', repr=False)     # summary
    authors = attr.ib(factory=tuple, repr=False)                # author{,_email}, maintainer{,_email}
    links = attr.ib(factory=dict, repr=False)                   # project_url{,s}, package_url
    classifiers = attr.ib(factory=tuple, repr=False)            # classifiers

    # info from requirements file
    editable = attr.ib(type=bool, default=False, repr=False)
    # https://github.com/pypa/packaging/blob/master/packaging/markers.py
    marker = attr.ib(type=Optional[Markers], default=None, repr=False)

    extra = None
    _is_extra_dep = False

    # constructors

    @classmethod
    def from_requirement(cls, source, req, url=None, editable=False) -> List['Dependency']:
        # for ExtraDependency we have to use Dependency.from_requirement
        if cls._is_extra_dep:
            cls = Dependency
        if type(req) is str:
            req = PackagingRequirement(req)
        # https://github.com/pypa/packaging/blob/master/packaging/requirements.py
        link = parse_link(url or req.url)
        # make constraint
        constraint = Constraint(source, req.specifier)
        if isinstance(link, VCSLink) and link.rev:
            constraint._specs[source.name] = GitSpecifier()
        if req.marker is not None:
            marker = Markers(req.marker)
        else:
            marker = None

        base_dep = cls(
            raw_name=req.name,
            constraint=constraint,
            repo=get_repo(link),
            link=link,
            marker=marker,
            editable=editable,
        )
        deps = [base_dep]
        if req.extras:
            from .extra_dependency import ExtraDependency
            for extra in req.extras:
                deps.append(ExtraDependency.from_dep(dep=base_dep, extra=extra))
        return deps

    @classmethod
    def from_params(cls, *, raw_name: str, constraint,
                    url: Optional[str] = None, source: Optional['Dependency'] = None,
                    repo=None, marker=None, extras: Optional[List[str]] = None, **kwargs) -> List['Dependency']:
        # make link
        link = parse_link(url)
        if link and link.name and rex_hash.fullmatch(raw_name):
            raw_name = link.name
        # make constraint
        if source:
            constraint = Constraint(source, constraint)
            if isinstance(link, VCSLink) and link.rev:
                constraint._specs[source.name] = GitSpecifier()
        # make repo
        if repo is None:
            repo = get_repo(link)
        if marker is not None:
            marker = Markers(marker)
        base_dep = cls(
            link=link,
            repo=repo,
            raw_name=raw_name,
            constraint=constraint,
            marker=marker,
            **kwargs,
        )
        deps = [base_dep]
        if extras:
            from .extra_dependency import ExtraDependency
            for extra in extras:
                deps.append(ExtraDependency.from_dep(dep=base_dep, extra=extra))
        return deps

    # properties

    @cached_property
    def name(self) -> str:
        return canonicalize_name(self.raw_name)

    @property
    def base_name(self) -> str:
        return self.name

    @cached_property
    def groups(self) -> Groups:
        return Groups(dep=self)

    @cached_property
    def group(self):
        """By first access choose and save best group
        """
        self.groups.actualize()
        for group in self.groups:
            if not group.empty:
                return group

    @property
    def dependencies(self) -> tuple:
        # for ExtraDependency we have to use Dependency.from_requirement
        cls = Dependency if self._is_extra_dep else type(self)

        deps = []
        for dep in self.group.dependencies:
            if isinstance(dep, cls):
                deps.append(dep)
            elif isinstance(dep, Iterable):
                deps.append(dep)
            else:
                deps.extend(cls.from_requirement(self, dep))
        return tuple(deps)

    @property
    def locked(self) -> bool:
        return 'group' in self.__dict__

    @property
    def python_compat(self) -> bool:
        if self.marker is None:
            return True
        needed = self.marker.python_version
        if needed is None:
            return True

        if self.locked:
            required = self.group.best_release.python
            if required is None:
                return True
            return (needed + required).python_compat

        for group in self.groups:
            if group.empty:
                continue
            required = group.best_release.python
            if required is None:
                return True
            if (needed + required).python_compat:
                return True
        return False

    @property
    def compat(self) -> bool:
        # if group has already choosed
        if self.locked:
            return not self.group.empty
        # if group hasn't choosed
        for group in self.groups:
            if not group.empty:
                return True
        return False

    @property
    def used(self) -> bool:
        """True if some deps in graph depends on this dep.
        """
        return not self.constraint.empty

    # methods

    def unlock(self) -> None:
        del self.__dict__['group']
        # if 'dependencies' in self.__dict__:
        #     del self.__dict__['dependencies']

    def __iadd__(self, dep: 'Dependency') -> 'Dependency':
        if not isinstance(dep, type(self)):
            return NotImplemented

        # some checks when we merge two git based dep
        if isinstance(self.link, GitRepo) and isinstance(dep.link, GitRepo):
            # links point to different revisions
            if self.link.rev and dep.link.rev and self.link.rev != dep.link.rev:
                return NotImplemented
            # links point to different servers
            if self.link.server != dep.link.server:
                return NotImplemented
            ...

        # if ...
        # .. 1. we don't use repo in self,
        # .. 2. it's a git repo,
        # .. 3. dep has non-git repo,
        # .. 4. self has no rev,
        # then prefer non-git repo, because it's more accurate and fast.
        if isinstance(self.link, GitRepo) and not isinstance(dep.link, GitRepo):
            if not self.link.rev:
                if not self.groups._loaded_groups:
                    self.repo = dep.repo

        if not isinstance(self.link, GitRepo) and isinstance(dep.link, GitRepo):
            self.link = dep.link
            self.repo = dep.repo

        self.constraint.merge(dep.constraint)
        self.groups.actualize()
        return self

    def __add__(self, dep: 'Dependency') -> 'Dependency':
        new = self.copy()
        new += dep
        return dep

    def __lt__(self, other):
        return self.name < other.name

    def unapply(self, name: str) -> None:
        self.constraint.unapply(name)
        if self.locked:
            self.unlock()

    def copy(self) -> 'Dependency':
        obj = deepcopy(self)
        obj.constraint = self.constraint.copy()
        if obj.locked:
            obj.unlock()
        return obj
